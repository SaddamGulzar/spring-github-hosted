name: Java CI/CD with Docker (Build on VM with SSH key)

on:
  push:
    branches: ["main"]

jobs:
  build-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VM_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VM_IP }} >> ~/.ssh/known_hosts

      - name: Build and Deploy on VM
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VM_USER }}@${{ secrets.VM_IP }} << EOF
            set -e

            # Install Java if missing
            if ! command -v java &> /dev/null; then
              sudo apt-get update
              sudo apt-get install -y openjdk-17-jdk
            fi
            export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
            export PATH=\$JAVA_HOME/bin:\$PATH
            java -version

            # Install Docker if missing
            if ! command -v docker &> /dev/null; then
              sudo apt-get update
              sudo apt-get install -y docker.io
            fi

            # Clone repo if missing
            if [ ! -d spring-github-hosted ]; then
              git clone git@github.com:SaddamGulzar/spring-github-hosted.git spring-github-hosted
            fi
            cd spring-github-hosted
            git fetch --all
            git reset --hard origin/main

            # Make wrappers executable
            [ -f "./mvnw" ] && chmod +x ./mvnw
            [ -f "./gradlew" ] && chmod +x ./gradlew

            # Build JAR
            if [ -f "pom.xml" ]; then
              ./mvnw clean package -DskipTests
              JAR_FILE=\$(ls target/*.jar | head -n 1)
            elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
              ./gradlew clean build -x test
              JAR_FILE=\$(ls build/libs/*.jar | head -n 1)
            else
              echo "No build file found!"
              exit 1
            fi

            echo "Using JAR: \$JAR_FILE"

            # Remove old container if exists
            if [ "\$(docker ps -aq -f name=spring-app)" ]; then
              docker rm -f spring-app || true
            fi

            # Remove old image if exists
            if [ "\$(docker images -q spring-app:latest)" ]; then
              docker rmi -f spring-app:latest || true
            fi

            # Build Docker image
            docker build --build-arg JAR_FILE=\$JAR_FILE -t spring-app:latest .

            # Free port 8086 if busy
            if lsof -t -i :8086; then
              sudo lsof -t -i :8086 | xargs sudo kill -9 || true
            fi

            # Run container with port 8086
            docker run -d --name spring-app -p 8086:8086 -e SERVER_PORT=8086 spring-app:latest || \
            (echo "Container failed to start. Logs:" && docker logs spring-app && exit 1)
          EOF

  test:
    runs-on: ubuntu-latest
    needs: build-deploy

    steps:
      - name: Wait for app to be ready
        run: |
          echo "Waiting for app on port 8086..."
          MAX_RETRIES=30
          COUNT=0
          until curl -s http://${{ secrets.VM_IP }}:8086/actuator/health || [ $COUNT -ge $MAX_RETRIES ]; do
            echo "App not ready yet. Retrying in 5s..."
            sleep 5
            COUNT=$((COUNT+1))
          done
          if [ $COUNT -ge $MAX_RETRIES ]; then
            echo "App did not start in time. Fetching container logs..."
            ssh -o StrictHostKeyChecking=no ${{ secrets.VM_USER }}@${{ secrets.VM_IP }} "docker logs spring-app || true"
            exit 1
          fi
          echo "App is up and running!"

      - name: Run tests on VM
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VM_USER }}@${{ secrets.VM_IP }} << EOF
            cd spring-github-hosted
            if [ -f "pom.xml" ]; then
              ./mvnw test
            elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
              ./gradlew test
            fi
          EOF
