name: Java CI/CD with Docker

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p $HOME/.ssh
          echo "${{ secrets.VM_SSH_KEY }}" > $HOME/.ssh/id_rsa
          chmod 600 $HOME/.ssh/id_rsa

      - name: Deploy to VM
        run: |
          ssh -i $HOME/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USER }}@${{ secrets.VM_IP }} << 'EOF'
            set -e
            APP_NAME="spring-app"
            APP_PORT=8086
            PROJECT_DIR=~/spring-github-hosted

            cd $PROJECT_DIR
            git fetch --all
            git reset --hard origin/main

            LAST_COMMIT_FILE=".last_deployed_commit"
            CURRENT_COMMIT=$(git rev-parse HEAD)

            if [ -f "$LAST_COMMIT_FILE" ] && [ "$(cat $LAST_COMMIT_FILE)" = "$CURRENT_COMMIT" ]; then
              echo "No code changes. Skipping build."
            else
              echo "Building JAR..."
              if [ -f "pom.xml" ] || [ -f "mvnw" ]; then
                ./mvnw clean package -DskipTests
                JAR_FILE=$(ls target/*.jar | head -n1)
              elif [ -f "build.gradle" ] || [ -f "gradlew" ]; then
                ./gradlew clean build -x test
                JAR_FILE=$(ls build/libs/*.jar | head -n1)
              else
                echo "❌ No build file found!"
                exit 1
              fi

              echo "Stopping old container..."
              docker stop $APP_NAME || true
              docker rm $APP_NAME || true

              echo "Cleaning old Docker resources..."
              CURRENT_IMAGE=$(docker images -q $APP_NAME:latest)
              docker ps -a --filter "name=$APP_NAME" --format "{{.ID}}" | grep -v "$(docker ps -q --filter "name=$APP_NAME")" | xargs -r docker rm -f
              docker images $APP_NAME --format "{{.ID}}" | grep -v "$CURRENT_IMAGE" | xargs -r docker rmi -f

              echo "Building Docker image..."
              cp $JAR_FILE app.jar
              cat > Dockerfile.temp <<- DOCKER_EOF
FROM eclipse-temurin:17-jdk-alpine
WORKDIR /app
COPY app.jar app.jar
EXPOSE $APP_PORT
ENTRYPOINT ["java","-jar","app.jar","--server.port=$APP_PORT"]
DOCKER_EOF
              docker build -f Dockerfile.temp -t $APP_NAME:latest .
              rm Dockerfile.temp

              echo "Starting container..."
              docker run -d --name $APP_NAME -p $APP_PORT:8080 $APP_NAME:latest

              echo "$CURRENT_COMMIT" > $LAST_COMMIT_FILE
            fi
          EOF

  test:
    runs-on: ubuntu-latest
    needs: deploy

    steps:
      - name: Quick Health Check
        run: |
          MAX_RETRIES=10
          COUNT=0
          SUCCESS=0
          until [ $COUNT -ge $MAX_RETRIES ]; do
            if curl -s http://${{ secrets.VM_IP }}:8086/actuator/health | grep -q '"status":"UP"'; then
              SUCCESS=1
              break
            fi
            echo "Waiting for app... ($COUNT/$MAX_RETRIES)"
            COUNT=$((COUNT+1))
            sleep 5
          done

          if [ $SUCCESS -ne 1 ]; then
            echo "❌ App health check failed."
            ssh -i $HOME/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ secrets.VM_USER }}@${{ secrets.VM_IP }} "docker logs spring-app || true"
            exit 1
          fi

          echo "✅ App is running and healthy."
